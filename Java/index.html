<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Java Programming Guide</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
        }

        header h1 {
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .nav-tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 10px;
        }

        .nav-tab {
            padding: 15px 25px;
            background: white;
            border: none;
            border-radius: 8px;
            margin: 0 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .nav-tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transform: translateY(-2px);
        }

        .nav-tab:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .content-section {
            display: none;
            animation: fadeIn 0.5s ease-in;
        }

        .content-section.active {
            display: block;
        }

        .topic-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #667eea;
        }

        .topic-card h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        .code-block {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            overflow-x: auto;
            margin: 15px 0;
        }

        .highlight {
            background: rgba(102, 126, 234, 0.1);
            padding: 15px;
            border-left: 4px solid #667eea;
            border-radius: 4px;
            margin: 15px 0;
        }

        .scenario-list {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .scenario-list ul {
            margin: 0;
            padding-left: 20px;
        }

        .scenario-list li {
            margin-bottom: 8px;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @media (max-width: 768px) {
            .nav-tabs {
                flex-direction: column;
            }
            
            .nav-tab {
                margin: 5px 0;
            }
            
            header h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>‚òï Complete Java Programming Guide</h1>
            <p>Master Java from fundamentals to advanced concepts with practical examples</p>
        </header>

        <nav class="nav-tabs">
            <button class="nav-tab active" onclick="showSection('fundamentals')">Fundamentals</button>
            <button class="nav-tab" onclick="showSection('oop')">OOP Concepts</button>
            <button class="nav-tab" onclick="showSection('advanced')">Advanced</button>
            <button class="nav-tab" onclick="showSection('best-practices')">Best Practices</button>
        </nav>

        <!-- Fundamentals Section -->
        <div id="fundamentals" class="content-section active">
            <h2>üéØ Java Fundamentals</h2>
            
            <div class="topic-card">
                <h3>1. Variables and Data Types</h3>
                <p>Java is strongly typed, meaning every variable must have a declared type.</p>
                
                <div class="code-block">// Primitive data types
byte smallNumber = 127;           // 8-bit signed integer
short shortNumber = 32767;        // 16-bit signed integer  
int number = 2147483647;          // 32-bit signed integer
long bigNumber = 9223372036854775807L; // 64-bit signed integer

float decimal = 3.14f;            // 32-bit floating point
double preciseDecimal = 3.14159;  // 64-bit floating point

char character = 'A';             // 16-bit Unicode character
boolean isTrue = true;            // true or false

// Reference types
String text = "Hello Java";       // String object
Integer boxedInt = 42;            // Wrapper class</div>

                <div class="highlight">
                    <strong>Best Practice:</strong> Use appropriate data types for memory efficiency. Use <code>int</code> for most numbers, <code>double</code> for decimals, and <code>String</code> for text.
                </div>

                <div class="scenario-list">
                    <h4>When to Use Each Type:</h4>
                    <ul>
                        <li><strong>int:</strong> Counters, array indices, small whole numbers</li>
                        <li><strong>long:</strong> Large numbers, timestamps, database IDs</li>
                        <li><strong>double:</strong> Prices, measurements, scientific calculations</li>
                        <li><strong>boolean:</strong> Flags, conditions, yes/no values</li>
                        <li><strong>String:</strong> Names, messages, any text data</li>
                    </ul>
                </div>
            </div>

            <div class="topic-card">
                <h3>2. Control Structures</h3>
                <p>Control the flow of your program with conditional statements and loops.</p>
                
                <div class="code-block">// If-else statements
int score = 85;
if (score >= 90) {
    System.out.println("Grade: A");
} else if (score >= 80) {
    System.out.println("Grade: B");
} else {
    System.out.println("Grade: C");
}

// Enhanced switch (Java 12+)
String result = switch (day) {
    case "Monday" -> "Start of work week";
    case "Friday" -> "TGIF!";
    case "Saturday", "Sunday" -> "Weekend!";
    default -> "Regular day";
};

// Enhanced for loop
String[] fruits = {"apple", "banana", "cherry"};
for (String fruit : fruits) {
    System.out.println(fruit);
}</div>

                <div class="scenario-list">
                    <h4>Usage Scenarios:</h4>
                    <ul>
                        <li><strong>if-else:</strong> Simple decision making</li>
                        <li><strong>switch:</strong> Multiple discrete values (menu options, status codes)</li>
                        <li><strong>for loop:</strong> Known number of iterations</li>
                        <li><strong>enhanced for:</strong> Iterating through collections/arrays</li>
                        <li><strong>while loop:</strong> Condition-based iteration</li>
                    </ul>
                </div>
            </div>

            <div class="topic-card">
                <h3>3. Methods</h3>
                <p>Organize code into reusable blocks with methods.</p>
                
                <div class="code-block">// Method with parameters and return type
public static int addNumbers(int a, int b) {
    return a + b;
}

// Method with variable arguments (varargs)
public static int sumAll(int... numbers) {
    int total = 0;
    for (int num : numbers) {
        total += num;
    }
    return total;
}

// Method overloading
public static int multiply(int a, int b) {
    return a * b;
}

public static double multiply(double a, double b) {
    return a * b;
}</div>

                <div class="highlight">
                    <strong>Method Design Principles:</strong>
                    <ul>
                        <li>Keep methods small and focused (single responsibility)</li>
                        <li>Use descriptive names that indicate what the method does</li>
                        <li>Minimize parameters (ideally 3 or fewer)</li>
                        <li>Validate input parameters</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- OOP Section -->
        <div id="oop" class="content-section">
            <h2>üèóÔ∏è Object-Oriented Programming</h2>
            
            <div class="topic-card">
                <h3>1. Encapsulation</h3>
                <p>Hide internal implementation details and provide controlled access to data.</p>
                
                <div class="code-block">public class BankAccount {
    // Private fields (encapsulated data)
    private String accountNumber;
    private double balance;
    
    // Constructor
    public BankAccount(String accountNumber, double initialBalance) {
        this.accountNumber = accountNumber;
        if (initialBalance >= 0) {
            this.balance = initialBalance;
        }
    }
    
    // Public methods for controlled access
    public void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
        }
    }
    
    public boolean withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            return true;
        }
        return false;
    }
    
    // Getter method (read-only access)
    public double getBalance() {
        return balance;
    }
}</div>

                <div class="scenario-list">
                    <h4>Why Use Encapsulation:</h4>
                    <ul>
                        <li><strong>Data Protection:</strong> Prevent invalid states</li>
                        <li><strong>Maintainability:</strong> Change implementation without affecting clients</li>
                        <li><strong>Security:</strong> Control access to sensitive data</li>
                        <li><strong>Debugging:</strong> Easier to track data changes</li>
                    </ul>
                </div>
            </div>

            <div class="topic-card">
                <h3>2. Inheritance</h3>
                <p>Create new classes based on existing ones to promote code reuse.</p>
                
                <div class="code-block">// Base class
public class Vehicle {
    protected String brand;
    protected String model;
    protected int year;
    
    public Vehicle(String brand, String model, int year) {
        this.brand = brand;
        this.model = model;
        this.year = year;
    }
    
    public void start() {
        System.out.println(brand + " " + model + " is starting...");
    }
}

// Derived class
public class Car extends Vehicle {
    private int numberOfDoors;
    
    public Car(String brand, String model, int year, int doors) {
        super(brand, model, year);  // Call parent constructor
        this.numberOfDoors = doors;
    }
    
    @Override
    public void start() {
        System.out.println("Car " + brand + " " + model + " engine started.");
    }
    
    public void honk() {
        System.out.println(brand + " " + model + " goes BEEP BEEP!");
    }
}</div>

                <div class="highlight">
                    <strong>Inheritance Best Practices:</strong>
                    <ul>
                        <li>Use inheritance for "is-a" relationships (Car is-a Vehicle)</li>
                        <li>Favor composition over inheritance when possible</li>
                        <li>Keep inheritance hierarchies shallow (3-4 levels max)</li>
                        <li>Use protected for fields that subclasses need</li>
                    </ul>
                </div>
            </div>

            <div class="topic-card">
                <h3>3. Polymorphism</h3>
                <p>Same interface, different implementations - the foundation of flexible design.</p>
                
                <div class="code-block">// Abstract base class
public abstract class Shape {
    protected String color;
    
    public Shape(String color) {
        this.color = color;
    }
    
    // Abstract methods - must be implemented
    public abstract double calculateArea();
    public abstract void draw();
}

// Concrete implementations
public class Circle extends Shape {
    private double radius;
    
    public Circle(String color, double radius) {
        super(color);
        this.radius = radius;
    }
    
    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
    
    @Override
    public void draw() {
        System.out.println("Drawing a " + color + " circle");
    }
}

// Using polymorphism
Shape[] shapes = {
    new Circle("red", 5.0),
    new Rectangle("blue", 4.0, 6.0),
    new Triangle("green", 3.0, 4.0)
};

for (Shape shape : shapes) {
    shape.draw();  // Calls appropriate implementation
    System.out.println("Area: " + shape.calculateArea());
}</div>

                <div class="scenario-list">
                    <h4>Polymorphism Applications:</h4>
                    <ul>
                        <li><strong>Plugin Architecture:</strong> Different implementations of same interface</li>
                        <li><strong>Strategy Pattern:</strong> Different algorithms for same task</li>
                        <li><strong>Factory Pattern:</strong> Creating objects without specifying exact class</li>
                        <li><strong>Collections:</strong> Working with different data structures uniformly</li>
                    </ul>
                </div>
            </div>

            <div class="topic-card">
                <h3>4. Interfaces</h3>
                <p>Define contracts that classes must implement, enabling multiple inheritance of type.</p>
                
                <div class="code-block">// Interface definition
public interface Drawable {
    void draw();
    void setVisible(boolean visible);
    
    // Default method (Java 8+)
    default void highlight() {
        System.out.println("Highlighting the drawable object");
    }
    
    // Static method (Java 8+)
    static void printInfo() {
        System.out.println("This is a drawable interface");
    }
}

// Multiple interface implementation
public class GameObject implements Drawable, Movable {
    private boolean visible = true;
    
    @Override
    public void draw() {
        if (visible) {
            System.out.println("Rendering game object");
        }
    }
    
    @Override
    public void setVisible(boolean visible) {
        this.visible = visible;
    }
    
    @Override
    public void move(int x, int y) {
        System.out.println("Moving to (" + x + ", " + y + ")");
    }
}</div>

                <div class="highlight">
                    <strong>Interface vs Abstract Class:</strong><br>
                    <strong>Use Interfaces when:</strong> You need multiple inheritance, defining contracts<br>
                    <strong>Use Abstract Classes when:</strong> You have common implementation to share
                </div>
            </div>
        </div>

        <!-- Advanced Section -->
        <div id="advanced" class="content-section">
            <h2>üöÄ Advanced Java Concepts</h2>
            
            <div class="topic-card">
                <h3>1. Collections Framework</h3>
                <p>Powerful data structures for storing and manipulating groups of objects.</p>
                
                <div class="code-block">// Lists - ordered, allow duplicates
List&lt;String&gt; arrayList = new ArrayList&lt;&gt;();  // Fast random access
List&lt;String&gt; linkedList = new LinkedList&lt;&gt;(); // Fast insertion/deletion

// Sets - no duplicates
Set&lt;String&gt; hashSet = new HashSet&lt;&gt;();      // Fast lookup, no order
Set&lt;String&gt; treeSet = new TreeSet&lt;&gt;();      // Sorted, slower

// Maps - key-value pairs
Map&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;();    // Fast lookup
Map&lt;String, Integer&gt; treeMap = new TreeMap&lt;&gt;();    // Sorted keys

// Working with collections
List&lt;Student&gt; students = Arrays.asList(
    new Student("Alice", 3.8),
    new Student("Bob", 3.2),
    new Student("Charlie", 3.9)
);

// Sorting
students.sort(Comparator.comparing(Student::getGpa).reversed());</div>

                <div class="scenario-list">
                    <h4>Collection Selection Guide:</h4>
                    <ul>
                        <li><strong>ArrayList:</strong> Default choice for lists, good for reading</li>
                        <li><strong>LinkedList:</strong> Frequent insertions/deletions in middle</li>
                        <li><strong>HashMap:</strong> Fast key-value lookups, most common map</li>
                        <li><strong>TreeMap:</strong> Need sorted keys or range operations</li>
                        <li><strong>HashSet:</strong> Fast membership testing, unique elements</li>
                        <li><strong>TreeSet:</strong> Unique sorted elements</li>
                    </ul>
                </div>
            </div>

            <div class="topic-card">
                <h3>2. Generics</h3>
                <p>Type safety and elimination of casting through parameterized types.</p>
                
                <div class="code-block">// Generic class
public class Container&lt;T&gt; {
    private T item;
    
    public void setItem(T item) {
        this.item = item;
    }
    
    public T getItem() {
        return item;
    }
}

// Generic method with bounded type
public static &lt;T extends Number&gt; double average(List&lt;T&gt; numbers) {
    double sum = 0.0;
    for (T number : numbers) {
        sum += number.doubleValue();
    }
    return sum / numbers.size();
}

// Wildcards
public static void printList(List&lt;?&gt; list) {           // Any type
public static void printNumbers(List&lt;? extends Number&gt; list) {  // Upper bound
public static void addIntegers(List&lt;? super Integer&gt; list) {   // Lower bound

// Usage
Container&lt;String&gt; stringContainer = new Container&lt;&gt;();
Container&lt;Integer&gt; intContainer = new Container&lt;&gt;();

List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);
double avg = average(numbers);  // Type-safe, no casting needed</div>

                <div class="highlight">
                    <strong>Generics Benefits:</strong>
                    <ul>
                        <li><strong>Type Safety:</strong> Compile-time error detection</li>
                        <li><strong>No Casting:</strong> Eliminates explicit type casting</li>
                        <li><strong>Code Reuse:</strong> Same code works with different types</li>
                        <li><strong>Performance:</strong> No runtime type checking overhead</li>
                    </ul>
                </div>
            </div>

            <div class="topic-card">
                <h3>3. Lambda Expressions and Streams</h3>
                <p>Functional programming features for more expressive and concise code.</p>
                
                <div class="code-block">// Lambda expressions
Predicate&lt;String&gt; isLongName = name -&gt; name.length() &gt; 5;
Function&lt;String, Integer&gt; stringLength = String::length;
Consumer&lt;String&gt; printUpper = str -&gt; System.out.println(str.toUpperCase());

List&lt;Student&gt; students = getStudents();

// Stream operations
List&lt;String&gt; csStudents = students.stream()
    .filter(s -&gt; s.getMajor().equals("Computer Science"))
    .filter(s -&gt; s.getGpa() &gt; 3.5)
    .map(Student::getName)
    .sorted()
    .collect(Collectors.toList());

// Statistical operations
DoubleSummaryStatistics gpaStats = students.stream()
    .mapToDouble(Student::getGpa)
    .summaryStatistics();

// Grouping
Map&lt;String, List&lt;Student&gt;&gt; studentsByMajor = students.stream()
    .collect(Collectors.groupingBy(Student::getMajor));

// Parallel processing
long count = students.parallelStream()
    .filter(s -&gt; s.getAge() &gt;= 21)
    .count();</div>

                <div class="scenario-list">
                    <h4>When to Use Streams:</h4>
                    <ul>
                        <li><strong>Data Processing:</strong> Filtering, mapping, reducing collections</li>
                        <li><strong>Database-like Operations:</strong> Group by, aggregate, join</li>
                        <li><strong>Parallel Processing:</strong> CPU-intensive operations on large datasets</li>
                        <li><strong>Functional Style:</strong> Declarative code that reads like English</li>
                    </ul>
                </div>
            </div>

            <div class="topic-card">
                <h3>4. Exception Handling</h3>
                <p>Robust error handling for reliable applications.</p>
                
                <div class="code-block">// Custom exception
public class InsufficientFundsException extends Exception {
    private double requestedAmount;
    private double availableBalance;
    
    public InsufficientFundsException(double requested, double available) {
        super("Insufficient funds: Requested $" + requested + 
              ", Available $" + available);
        this.requestedAmount = requested;
        this.availableBalance = available;
    }
}

// Exception handling in methods
public void withdraw(double amount) throws InsufficientFundsException {
    if (amount &gt; balance) {
        throw new InsufficientFundsException(amount, balance);
    }
    balance -= amount;
}

// Try-with-resources (automatic resource management)
try (FileReader reader = new FileReader("data.txt");
     BufferedReader buffered = new BufferedReader(reader)) {
    
    return buffered.lines()
        .filter(line -&gt; !line.isEmpty())
        .collect(Collectors.toList());
        
} catch (IOException e) {
    System.err.println("File error: " + e.getMessage());
    return Collections.emptyList();
}

// Multiple exception handling
try {
    processPayment();
} catch (InsufficientFundsException e) {
    handleInsufficientFunds(e);
} catch (NetworkException e) {
    retryLater(e);
} catch (Exception e) {
    logUnexpectedError(e);
    throw new ServiceException("Payment processing failed", e);
}</div>

                <div class="highlight">
                    <strong>Exception Handling Strategy:</strong><br>
                    <strong>Checked Exceptions:</strong> For recoverable conditions (file not found, network issues)<br>
                    <strong>Unchecked Exceptions:</strong> For programming errors (null pointer, array bounds)<br>
                    <strong>Custom Exceptions:</strong> For domain-specific error conditions
                </div>
            </div>
        </div>

        <!-- Best Practices Section -->
        <div id="best-practices" class="content-section">
            <h2>‚ú® Best Practices and Modern Java</h2>
            
            <div class="topic-card">
                <h3>1. Code Quality and Style</h3>
                <p>Write clean, readable, and maintainable code.</p>
                
                <div class="code-block">// ‚úÖ Good naming conventions
public class CustomerService {
    private static final int MAX_RETRY_ATTEMPTS = 3;
    private final PaymentProcessor paymentProcessor;
    
    public boolean processCustomerPayment(Customer customer, Payment payment) {
        // Method does exactly what the name suggests
    }
}

// ‚úÖ Use Optional instead of null
public Optional&lt;Customer&gt; findCustomerById(String customerId) {
    Customer customer = database.findById(customerId);
    return Optional.ofNullable(customer);
}

// Usage
Optional&lt;Customer&gt; customer = customerService.findCustomerById("123");
customer.ifPresent(c -&gt; processCustomer(c));
String name = customer.map(Customer::getName).orElse("Unknown");

// ‚úÖ Use modern Java features
var customers = List.of(          // var keyword (Java 10+)
    new Customer("Alice"),
    new Customer("Bob")
);

// Text blocks (Java 15+)
String json = """
    {
        "name": "John Doe",
        "age": 30,
        "email": "john@example.com"
    }
    """;</div>

                <div class="scenario-list">
                    <h4>Code Quality Checklist:</h4>
                    <ul>
                        <li><strong>Naming:</strong> Use descriptive names that reveal intent</li>
                        <li><strong>Methods:</strong> Keep them small (one screen), single purpose</li>
                        <li><strong>Classes:</strong> High cohesion, low coupling</li>
                        <li><strong>Constants:</strong> Use static final for magic numbers/strings</li>
                        <li><strong>Validation:</strong> Validate inputs, fail fast</li>
                    </ul>
                </div>
            </div>

            <div class="topic-card">
                <h3>2. Design Patterns</h3>
                <p>Proven solutions to common programming problems.</p>
                
                <div class="code-block">// Singleton Pattern
public class DatabaseConnection {
    private static volatile DatabaseConnection instance;
    
    private DatabaseConnection() {}
    
    public static DatabaseConnection getInstance() {
        if (instance == null) {
            synchronized (DatabaseConnection.class) {
                if (instance == null) {
                    instance = new DatabaseConnection();
                }
            }
        }
        return instance;
    }
}

// Factory Pattern
public class ShapeFactory {
    public static Shape createShape(String type, double... params) {
        return switch (type.toLowerCase()) {
            case "circle" -&gt; new Circle(params[0]);
            case "rectangle" -&gt; new Rectangle(params[0], params[1]);
            case "triangle" -&gt; new Triangle(params[0], params[1], params[2]);
            default -&gt; throw new IllegalArgumentException("Unknown shape: " + type);
        };
    }
}

// Observer Pattern with modern Java
public class EventPublisher {
    private final List&lt;Consumer&lt;Event&gt;&gt; listeners = new ArrayList&lt;&gt;();
    
    public void subscribe(Consumer&lt;Event&gt; listener) {
        listeners.add(listener);
    }
    
    public void publish(Event event) {
        listeners.forEach(listener -&gt; listener.accept(event));
    }
}</div>

                <div class="scenario-list">
                    <h4>When to Use Design Patterns:</h4>
                    <ul>
                        <li><strong>Singleton:</strong> Database connections, loggers, configuration</li>
                        <li><strong>Factory:</strong> Object creation based on input parameters</li>
                        <li><strong>Observer:</strong> Event systems, model-view separation</li>
                        <li><strong>Strategy:</strong> Different algorithms for same task</li>
                        <li><strong>Builder:</strong> Complex object construction</li>
                    </ul>
                </div>
            </div>

            <div class="topic-card">
                <h3>3. Performance and Memory Management</h3>
                <p>Write efficient code that scales well.</p>
                
                <div class="code-block">// ‚úÖ Use StringBuilder for string concatenation
StringBuilder sb = new StringBuilder();
for (String item : items) {
    sb.append(item).append(", ");
}
String result = sb.toString();

// ‚úÖ Use appropriate collection sizes
List&lt;String&gt; list = new ArrayList&lt;&gt;(expectedSize);  // Avoid resizing
Map&lt;String, String&gt; map = new HashMap&lt;&gt;(expectedSize, 0.75f);

// ‚úÖ Stream vs traditional loops - choose wisely
// For simple operations, traditional loops might be faster
int sum = 0;
for (int number : numbers) {
    sum += number;
}

// For complex operations, streams are more readable
Map&lt;Department, Double&gt; avgSalaryByDept = employees.stream()
    .collect(Collectors.groupingBy(
        Employee::getDepartment,
        Collectors.averagingDouble(Employee::getSalary)
    ));

// ‚úÖ Use try-with-resources for automatic cleanup
try (var inputStream = Files.newInputStream(path);
     var reader = new BufferedReader(new InputStreamReader(inputStream))) {
    // Resources automatically closed
}</div>

                <div class="highlight">
                    <strong>Performance Tips:</strong>
                    <ul>
                        <li><strong>Profile First:</strong> Measure before optimizing</li>
                        <li><strong>Choose Right Collections:</strong> Know time complexities</li>
                        <li><strong>Avoid Premature Optimization:</strong> Write readable code first</li>
                        <li><strong>Use Parallel Streams:</strong> For CPU-intensive operations on large data</li>
                    </ul>
                </div>
            </div>

            <div class="topic-card">
                <h3>4. Testing and Documentation</h3>
                <p>Ensure code quality through testing and clear documentation.</p>
                
                <div class="code-block">/**
 * Calculates the compound interest for an investment.
 * 
 * @param principal the initial amount invested
 * @param rate the annual interest rate (as a decimal, e.g., 0.05 for 5%)
 * @param time the number of years
 * @param frequency the number of times interest is compounded per year
 * @return the final amount after compound interest
 * @throws IllegalArgumentException if any parameter is negative
 */
public double calculateCompoundInterest(double principal, double rate, 
                                       int time, int frequency) {
    if (principal &lt; 0 || rate &lt; 0 || time &lt; 0 || frequency &lt;= 0) {
        throw new IllegalArgumentException("All parameters must be non-negative");
    }
    
    return principal * Math.pow(1 + rate / frequency, frequency * time);
}

// Unit test example (conceptual)
@Test
public void testCompoundInterest() {
    double result = calculator.calculateCompoundInterest(1000, 0.05, 2, 12);
    assertEquals(1104.89, result, 0.01);
}

@Test(expected = IllegalArgumentException.class)
public void testNegativePrincipal() {
    calculator.calculateCompoundInterest(-1000, 0.05, 2, 12);
}</div>

                <div class="scenario-list">
                    <h4>Documentation Best Practices:</h4>
                    <ul>
                        <li><strong>Javadoc:</strong> Document all public APIs</li>
                        <li><strong>Code Comments:</strong> Explain why, not what</li>
                        <li><strong>README:</strong> Project overview and setup instructions</li>
                        <li><strong>Examples:</strong> Show typical usage patterns</li>
                        <li><strong>Tests as Documentation:</strong> Tests show expected behavior</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        function showSection(sectionId) {
            // Hide all sections
            const sections = document.querySelectorAll('.content-section');
            sections.forEach(section => section.classList.remove('active'));
            
            // Remove active class from all tabs
            const tabs = document.querySelectorAll('.nav-tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            // Show selected section
            document.getElementById(sectionId).classList.add('active');
            
            // Add active class to clicked tab
            event.target.classList.add('active');
        }
    </script>
</body>
</html>
